# Visit 2.6.2 log file
ScriptVersion = "2.6.2"
if ScriptVersion != Version():
    print "This script is for VisIt %s. It may not work with version %s" % (ScriptVersion, Version())
visit.ShowAllWindows()
OpenDatabase("localhost:/home/hannukse/meteo/lustre/tmp/hannuksela/pythonTests/velgrid.rotated.183300.*.silo database", 0)
# The UpdateDBPluginInfo RPC is not supported in the VisIt module so it will not be logged.
AnnotationAtts = AnnotationAttributes()
AnnotationAtts.axes2D.visible = 1
AnnotationAtts.axes2D.autoSetTicks = 1
AnnotationAtts.axes2D.autoSetScaling = 1
AnnotationAtts.axes2D.lineWidth = 0
AnnotationAtts.axes2D.tickLocation = AnnotationAtts.axes2D.Outside  # Inside, Outside, Both
AnnotationAtts.axes2D.tickAxes = AnnotationAtts.axes2D.BottomLeft  # Off, Bottom, Left, BottomLeft, All
AnnotationAtts.axes2D.xAxis.title.visible = 1
AnnotationAtts.axes2D.xAxis.title.font.font = AnnotationAtts.axes2D.xAxis.title.font.Courier  # Arial, Courier, Times
AnnotationAtts.axes2D.xAxis.title.font.scale = 1
AnnotationAtts.axes2D.xAxis.title.font.useForegroundColor = 1
AnnotationAtts.axes2D.xAxis.title.font.color = (0, 0, 0, 255)
AnnotationAtts.axes2D.xAxis.title.font.bold = 1
AnnotationAtts.axes2D.xAxis.title.font.italic = 1
AnnotationAtts.axes2D.xAxis.title.userTitle = 0
AnnotationAtts.axes2D.xAxis.title.userUnits = 0
AnnotationAtts.axes2D.xAxis.title.title = "X-Axis"
AnnotationAtts.axes2D.xAxis.title.units = ""
AnnotationAtts.axes2D.xAxis.label.visible = 1
AnnotationAtts.axes2D.xAxis.label.font.font = AnnotationAtts.axes2D.xAxis.label.font.Courier  # Arial, Courier, Times
AnnotationAtts.axes2D.xAxis.label.font.scale = 1
AnnotationAtts.axes2D.xAxis.label.font.useForegroundColor = 1
AnnotationAtts.axes2D.xAxis.label.font.color = (0, 0, 0, 255)
AnnotationAtts.axes2D.xAxis.label.font.bold = 1
AnnotationAtts.axes2D.xAxis.label.font.italic = 1
AnnotationAtts.axes2D.xAxis.label.scaling = 0
AnnotationAtts.axes2D.xAxis.tickMarks.visible = 1
AnnotationAtts.axes2D.xAxis.tickMarks.majorMinimum = 0
AnnotationAtts.axes2D.xAxis.tickMarks.majorMaximum = 1
AnnotationAtts.axes2D.xAxis.tickMarks.minorSpacing = 0.02
AnnotationAtts.axes2D.xAxis.tickMarks.majorSpacing = 0.2
AnnotationAtts.axes2D.xAxis.grid = 0
AnnotationAtts.axes2D.yAxis.title.visible = 1
AnnotationAtts.axes2D.yAxis.title.font.font = AnnotationAtts.axes2D.yAxis.title.font.Courier  # Arial, Courier, Times
AnnotationAtts.axes2D.yAxis.title.font.scale = 1
AnnotationAtts.axes2D.yAxis.title.font.useForegroundColor = 1
AnnotationAtts.axes2D.yAxis.title.font.color = (0, 0, 0, 255)
AnnotationAtts.axes2D.yAxis.title.font.bold = 1
AnnotationAtts.axes2D.yAxis.title.font.italic = 1
AnnotationAtts.axes2D.yAxis.title.userTitle = 0
AnnotationAtts.axes2D.yAxis.title.userUnits = 0
AnnotationAtts.axes2D.yAxis.title.title = "Y-Axis"
AnnotationAtts.axes2D.yAxis.title.units = ""
AnnotationAtts.axes2D.yAxis.label.visible = 1
AnnotationAtts.axes2D.yAxis.label.font.font = AnnotationAtts.axes2D.yAxis.label.font.Courier  # Arial, Courier, Times
AnnotationAtts.axes2D.yAxis.label.font.scale = 1
AnnotationAtts.axes2D.yAxis.label.font.useForegroundColor = 1
AnnotationAtts.axes2D.yAxis.label.font.color = (0, 0, 0, 255)
AnnotationAtts.axes2D.yAxis.label.font.bold = 1
AnnotationAtts.axes2D.yAxis.label.font.italic = 1
AnnotationAtts.axes2D.yAxis.label.scaling = 0
AnnotationAtts.axes2D.yAxis.tickMarks.visible = 1
AnnotationAtts.axes2D.yAxis.tickMarks.majorMinimum = 0
AnnotationAtts.axes2D.yAxis.tickMarks.majorMaximum = 1
AnnotationAtts.axes2D.yAxis.tickMarks.minorSpacing = 0.02
AnnotationAtts.axes2D.yAxis.tickMarks.majorSpacing = 0.2
AnnotationAtts.axes2D.yAxis.grid = 0
AnnotationAtts.axes3D.visible = 1
AnnotationAtts.axes3D.autoSetTicks = 1
AnnotationAtts.axes3D.autoSetScaling = 1
AnnotationAtts.axes3D.lineWidth = 0
AnnotationAtts.axes3D.tickLocation = AnnotationAtts.axes3D.Inside  # Inside, Outside, Both
AnnotationAtts.axes3D.axesType = AnnotationAtts.axes3D.ClosestTriad  # ClosestTriad, FurthestTriad, OutsideEdges, StaticTriad, StaticEdges
AnnotationAtts.axes3D.triadFlag = 1
AnnotationAtts.axes3D.bboxFlag = 1
AnnotationAtts.axes3D.xAxis.title.visible = 1
AnnotationAtts.axes3D.xAxis.title.font.font = AnnotationAtts.axes3D.xAxis.title.font.Arial  # Arial, Courier, Times
AnnotationAtts.axes3D.xAxis.title.font.scale = 1
AnnotationAtts.axes3D.xAxis.title.font.useForegroundColor = 1
AnnotationAtts.axes3D.xAxis.title.font.color = (0, 0, 0, 255)
AnnotationAtts.axes3D.xAxis.title.font.bold = 0
AnnotationAtts.axes3D.xAxis.title.font.italic = 0
AnnotationAtts.axes3D.xAxis.title.userTitle = 0
AnnotationAtts.axes3D.xAxis.title.userUnits = 0
AnnotationAtts.axes3D.xAxis.title.title = "X-Axis"
AnnotationAtts.axes3D.xAxis.title.units = ""
AnnotationAtts.axes3D.xAxis.label.visible = 1
AnnotationAtts.axes3D.xAxis.label.font.font = AnnotationAtts.axes3D.xAxis.label.font.Arial  # Arial, Courier, Times
AnnotationAtts.axes3D.xAxis.label.font.scale = 1
AnnotationAtts.axes3D.xAxis.label.font.useForegroundColor = 1
AnnotationAtts.axes3D.xAxis.label.font.color = (0, 0, 0, 255)
AnnotationAtts.axes3D.xAxis.label.font.bold = 0
AnnotationAtts.axes3D.xAxis.label.font.italic = 0
AnnotationAtts.axes3D.xAxis.label.scaling = 0
AnnotationAtts.axes3D.xAxis.tickMarks.visible = 1
AnnotationAtts.axes3D.xAxis.tickMarks.majorMinimum = 0
AnnotationAtts.axes3D.xAxis.tickMarks.majorMaximum = 1
AnnotationAtts.axes3D.xAxis.tickMarks.minorSpacing = 0.02
AnnotationAtts.axes3D.xAxis.tickMarks.majorSpacing = 0.2
AnnotationAtts.axes3D.xAxis.grid = 0
AnnotationAtts.axes3D.yAxis.title.visible = 1
AnnotationAtts.axes3D.yAxis.title.font.font = AnnotationAtts.axes3D.yAxis.title.font.Arial  # Arial, Courier, Times
AnnotationAtts.axes3D.yAxis.title.font.scale = 1
AnnotationAtts.axes3D.yAxis.title.font.useForegroundColor = 1
AnnotationAtts.axes3D.yAxis.title.font.color = (0, 0, 0, 255)
AnnotationAtts.axes3D.yAxis.title.font.bold = 0
AnnotationAtts.axes3D.yAxis.title.font.italic = 0
AnnotationAtts.axes3D.yAxis.title.userTitle = 0
AnnotationAtts.axes3D.yAxis.title.userUnits = 0
AnnotationAtts.axes3D.yAxis.title.title = "Y-Axis"
AnnotationAtts.axes3D.yAxis.title.units = ""
AnnotationAtts.axes3D.yAxis.label.visible = 1
AnnotationAtts.axes3D.yAxis.label.font.font = AnnotationAtts.axes3D.yAxis.label.font.Arial  # Arial, Courier, Times
AnnotationAtts.axes3D.yAxis.label.font.scale = 1
AnnotationAtts.axes3D.yAxis.label.font.useForegroundColor = 1
AnnotationAtts.axes3D.yAxis.label.font.color = (0, 0, 0, 255)
AnnotationAtts.axes3D.yAxis.label.font.bold = 0
AnnotationAtts.axes3D.yAxis.label.font.italic = 0
AnnotationAtts.axes3D.yAxis.label.scaling = 0
AnnotationAtts.axes3D.yAxis.tickMarks.visible = 1
AnnotationAtts.axes3D.yAxis.tickMarks.majorMinimum = 0
AnnotationAtts.axes3D.yAxis.tickMarks.majorMaximum = 1
AnnotationAtts.axes3D.yAxis.tickMarks.minorSpacing = 0.02
AnnotationAtts.axes3D.yAxis.tickMarks.majorSpacing = 0.2
AnnotationAtts.axes3D.yAxis.grid = 0
AnnotationAtts.axes3D.zAxis.title.visible = 1
AnnotationAtts.axes3D.zAxis.title.font.font = AnnotationAtts.axes3D.zAxis.title.font.Arial  # Arial, Courier, Times
AnnotationAtts.axes3D.zAxis.title.font.scale = 1
AnnotationAtts.axes3D.zAxis.title.font.useForegroundColor = 1
AnnotationAtts.axes3D.zAxis.title.font.color = (0, 0, 0, 255)
AnnotationAtts.axes3D.zAxis.title.font.bold = 0
AnnotationAtts.axes3D.zAxis.title.font.italic = 0
AnnotationAtts.axes3D.zAxis.title.userTitle = 0
AnnotationAtts.axes3D.zAxis.title.userUnits = 0
AnnotationAtts.axes3D.zAxis.title.title = "Z-Axis"
AnnotationAtts.axes3D.zAxis.title.units = ""
AnnotationAtts.axes3D.zAxis.label.visible = 1
AnnotationAtts.axes3D.zAxis.label.font.font = AnnotationAtts.axes3D.zAxis.label.font.Arial  # Arial, Courier, Times
AnnotationAtts.axes3D.zAxis.label.font.scale = 1
AnnotationAtts.axes3D.zAxis.label.font.useForegroundColor = 1
AnnotationAtts.axes3D.zAxis.label.font.color = (0, 0, 0, 255)
AnnotationAtts.axes3D.zAxis.label.font.bold = 0
AnnotationAtts.axes3D.zAxis.label.font.italic = 0
AnnotationAtts.axes3D.zAxis.label.scaling = 0
AnnotationAtts.axes3D.zAxis.tickMarks.visible = 1
AnnotationAtts.axes3D.zAxis.tickMarks.majorMinimum = 0
AnnotationAtts.axes3D.zAxis.tickMarks.majorMaximum = 1
AnnotationAtts.axes3D.zAxis.tickMarks.minorSpacing = 0.02
AnnotationAtts.axes3D.zAxis.tickMarks.majorSpacing = 0.2
AnnotationAtts.axes3D.zAxis.grid = 0
AnnotationAtts.axes3D.setBBoxLocation = 0
AnnotationAtts.axes3D.bboxLocation = (0, 1, 0, 1, 0, 1)
AnnotationAtts.userInfoFlag = 0
AnnotationAtts.userInfoFont.font = AnnotationAtts.userInfoFont.Arial  # Arial, Courier, Times
AnnotationAtts.userInfoFont.scale = 1
AnnotationAtts.userInfoFont.useForegroundColor = 1
AnnotationAtts.userInfoFont.color = (0, 0, 0, 255)
AnnotationAtts.userInfoFont.bold = 0
AnnotationAtts.userInfoFont.italic = 0
AnnotationAtts.databaseInfoFlag = 1
AnnotationAtts.timeInfoFlag = 0
AnnotationAtts.databaseInfoFont.font = AnnotationAtts.databaseInfoFont.Arial  # Arial, Courier, Times
AnnotationAtts.databaseInfoFont.scale = 0.4
AnnotationAtts.databaseInfoFont.useForegroundColor = 1
AnnotationAtts.databaseInfoFont.color = (0, 0, 0, 255)
AnnotationAtts.databaseInfoFont.bold = 0
AnnotationAtts.databaseInfoFont.italic = 0
AnnotationAtts.databaseInfoExpansionMode = AnnotationAtts.File  # File, Directory, Full, Smart, SmartDirectory
AnnotationAtts.databaseInfoTimeScale = 1
AnnotationAtts.databaseInfoTimeOffset = 0
AnnotationAtts.legendInfoFlag = 1
AnnotationAtts.backgroundColor = (255, 255, 255, 255)
AnnotationAtts.foregroundColor = (0, 0, 0, 255)
AnnotationAtts.gradientBackgroundStyle = AnnotationAtts.Radial  # TopToBottom, BottomToTop, LeftToRight, RightToLeft, Radial
AnnotationAtts.gradientColor1 = (0, 0, 255, 255)
AnnotationAtts.gradientColor2 = (0, 0, 0, 255)
AnnotationAtts.backgroundMode = AnnotationAtts.Solid  # Solid, Gradient, Image, ImageSphere
AnnotationAtts.backgroundImage = ""
AnnotationAtts.imageRepeatX = 1
AnnotationAtts.imageRepeatY = 1
AnnotationAtts.axesArray.visible = 1
AnnotationAtts.axesArray.ticksVisible = 1
AnnotationAtts.axesArray.autoSetTicks = 1
AnnotationAtts.axesArray.autoSetScaling = 1
AnnotationAtts.axesArray.lineWidth = 0
AnnotationAtts.axesArray.axes.title.visible = 1
AnnotationAtts.axesArray.axes.title.font.font = AnnotationAtts.axesArray.axes.title.font.Arial  # Arial, Courier, Times
AnnotationAtts.axesArray.axes.title.font.scale = 1
AnnotationAtts.axesArray.axes.title.font.useForegroundColor = 1
AnnotationAtts.axesArray.axes.title.font.color = (0, 0, 0, 255)
AnnotationAtts.axesArray.axes.title.font.bold = 0
AnnotationAtts.axesArray.axes.title.font.italic = 0
AnnotationAtts.axesArray.axes.title.userTitle = 0
AnnotationAtts.axesArray.axes.title.userUnits = 0
AnnotationAtts.axesArray.axes.title.title = ""
AnnotationAtts.axesArray.axes.title.units = ""
AnnotationAtts.axesArray.axes.label.visible = 1
AnnotationAtts.axesArray.axes.label.font.font = AnnotationAtts.axesArray.axes.label.font.Arial  # Arial, Courier, Times
AnnotationAtts.axesArray.axes.label.font.scale = 1
AnnotationAtts.axesArray.axes.label.font.useForegroundColor = 1
AnnotationAtts.axesArray.axes.label.font.color = (0, 0, 0, 255)
AnnotationAtts.axesArray.axes.label.font.bold = 0
AnnotationAtts.axesArray.axes.label.font.italic = 0
AnnotationAtts.axesArray.axes.label.scaling = 0
AnnotationAtts.axesArray.axes.tickMarks.visible = 1
AnnotationAtts.axesArray.axes.tickMarks.majorMinimum = 0
AnnotationAtts.axesArray.axes.tickMarks.majorMaximum = 1
AnnotationAtts.axesArray.axes.tickMarks.minorSpacing = 0.02
AnnotationAtts.axesArray.axes.tickMarks.majorSpacing = 0.2
AnnotationAtts.axesArray.axes.grid = 0
SetAnnotationAttributes(AnnotationAtts)
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
DefineScalarExpression("volume/Vx", "rho_v[0] / rho")
DefineScalarExpression("volume/Vy", "rho_v[1]/rho")
DefineScalarExpression("volume/Vz", "rho_v[2]/rho")
DefineScalarExpression("edge/Ex", "E[0]")
DefineScalarExpression("edge/Ey", "E[1]")
DefineScalarExpression("edge/Ez", "E[2]")
DefineScalarExpression("face/Bx", "B[0]")
DefineScalarExpression("face/By", "B[1]")
DefineScalarExpression("face/Bz", "B[2]")
DefineScalarExpression("volume/Ex", "E_vol[0]")
DefineScalarExpression("volume/Ey", "E_vol[1]")
DefineScalarExpression("volume/Ez", "E_vol[2]")
DefineScalarExpression("volume/Bx", "B_vol[0]")
DefineScalarExpression("volume/By", "B_vol[1]")
DefineScalarExpression("volume/Bz", "B_vol[2]")
DefineScalarExpression("Total energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>) + (<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6) + 0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>) + 1.5 * Pressure / rho")
DefineScalarExpression("Electric energy", "0.5 * 8.85418781762e-12 * (<volume/Ex>*<volume/Ex> + <volume/Ey>*<volume/Ey> + <volume/Ez>*<volume/Ez>)")
DefineScalarExpression("Magnetic energy", "(<volume/Bx>*<volume/Bx> + <volume/By>*<volume/By> + <volume/Bz>*<volume/Bz>) / (2 * 1.25663706144e-6)")
DefineScalarExpression("Kinetic energy", "0.5 * 1.6726217e-27 * rho * (<volume/Vx>*<volume/Vx> + <volume/Vy>*<volume/Vy> + <volume/Vz>*<volume/Vz>)")
DefineScalarExpression("Thermal energy", "1.5 * Pressure / rho")
DefineScalarExpression("divB", "divergence({<face/Bx>, <face/By>, <face/Bz>})")
DefineScalarExpression("divB_scaled", "relative_size(SpatialGrid) * divergence({<face/Bx>, <face/By>, <face/Bz>}) / B_magnitude")
DefineTensorExpression("PTensor", "{{PTensorDiagonal[0], PTensorOffDiagonal[2], PTensorOffDiagonal[1]},{PTensorOffDiagonal[2], PTensorDiagonal[1], PTensorOffDiagonal[0]},{PTensorOffDiagonal[1], PTensorOffDiagonal[0], PTensorDiagonal[2]}}")
DefineVectorExpression("V", "{<volume/Vx>, <volume/Vy>, <volume/Vz>}")
DefineScalarExpression("face/perBx", "perturbed_B[0]")
DefineScalarExpression("face/perBy", "perturbed_B[1]")
DefineScalarExpression("face/perBz", "perturbed_B[2]")
DefineScalarExpression("V_magnitude", "magnitude(V)")
DefineScalarExpression("face/bgBx", "background_B[0]")
DefineScalarExpression("face/bgBy", "background_B[1]")
DefineScalarExpression("face/bgBz", "background_B[2]")
DefineVectorExpression("J", "(curl({<face/perBx>, <face/perBy>, <face/perBz>})) / 1.25663706144e-6")
DefineScalarExpression("J_magnitude", "magnitude(J)")
DefineVectorExpression("Hall", "cross(J,B)/(1.602177e-19 * (rho+0.1) )")
DefineScalarExpression("Hall_magnitude", "magnitude(Hall)")
DefineVectorExpression("V_parallel", "dot( V,B ) * B / (B_magnitude * B_magnitude )")
DefineVectorExpression("V_perp", "V-V_parallel")
DefineScalarExpression("V_parallel_magnitude", "magnitude(V_parallel)")
DefineScalarExpression("V_perp_magnitude", "magnitude(V_perp)")
DefineScalarExpression("alfvenicMachNumber", "V_magnitude*sqrt(1.256637e-6*1.6726e-27*rho)/B_magnitude")
DefineScalarExpression("Heli's criterion", "rho*<volume/Vx>*<volume/Vx>/ (1.0e6*25.0e10)")
DefineScalarExpression("gyrotropicity/theta", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   0.0,   acos(<volume/Bz> / B_vol_magnitude))")
DefineVectorExpression("gyrotropicity/u", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {0.0, 0.0, 0.0},   {<volume/By>, -<volume/Bx>, 0.0} / (B_vol_magnitude * sin(<gyrotropicity/theta>)))")
DefineScalarExpression("gyrotropicity/ux", "<gyrotropicity/u>[0]")
DefineScalarExpression("gyrotropicity/uy", "<gyrotropicity/u>[1]")
DefineScalarExpression("gyrotropicity/uz", "<gyrotropicity/u>[2]")
DefineTensorExpression("gyrotropicity/R", "if(   and(      eq(<volume/By>, 0.0),      eq(<volume/Bx>, 0.0)   ),   {{1.0, 0.0, 0.0},    {0.0, 1.0, 0.0},    {0.0, 0.0, 1.0}},   {      {cos(<gyrotropicity/theta>) + <gyrotropicity/ux>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/ux> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      <gyrotropicity/ux> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uy> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uy> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/uz> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uy>^2 * (1.0 - cos(<gyrotropicity/theta>)),      <gyrotropicity/uy> * <gyrotropicity/uz> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/ux> * sin(<gyrotropicity/theta>)},      {<gyrotropicity/uz> * <gyrotropicity/ux> * (1.0 - cos(<gyrotropicity/theta>)) - <gyrotropicity/uy> * sin(<gyrotropicity/theta>),      <gyrotropicity/uz> * <gyrotropicity/uy> * (1.0 - cos(<gyrotropicity/theta>)) + <gyrotropicity/ux> * sin(<gyrotropicity/theta>),      cos(<gyrotropicity/theta>) + <gyrotropicity/uz>^2 * (1.0 - cos(<gyrotropicity/theta>))}   })")
DefineTensorExpression("PTensor_rotated", "<gyrotropicity/R>*PTensor*transpose(<gyrotropicity/R>)")
DefineVectorExpression("gyrotropicity/V_to_B", "<gyrotropicity/R>*B_vol")
DefineScalarExpression("gyrotropicity/minDIagonalPressureDifference", "min(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineTensorExpression("gyrotropicity/invR", "inverse(<gyrotropicity/R>)")
DefineScalarExpression("gyrotropicity/maxDIagonalPressureDifference", "max(   2.0 * abs(PTensor_rotated[0][0] - PTensor_rotated[1][1]) / (PTensor_rotated[0][0] + PTensor_rotated[1][1]),   2.0 * abs(PTensor_rotated[1][1] - PTensor_rotated[2][2]) / (PTensor_rotated[1][1] + PTensor_rotated[2][2]))")
DefineScalarExpression("Temperature", "Pressure / ((rho + 1) * 1.38065e-23)")
DefineTensorExpression("TemperatureTensor", "{{PTensor[0][0]/rho, PTensor[0][1]/rho, PTensor[0][2]/rho},{PTensor[1][0]/rho, PTensor[1][1]/rho, PTensor[1][2]/rho},{PTensor[2][0]/rho, PTensor[2][1]/rho, PTensor[2][2]/rho}}")
DefineScalarExpression("TemperatureTensor_rotated", "<gyrotropicity/R>*TemperatureTensor*transpose(<gyrotropicity/R>)")
AddPlot("Pseudocolor", "avgs", 1, 1)
SetActivePlots(0)
AddOperator("Threshold", 1)
SetActivePlots(0)
ThresholdAtts = ThresholdAttributes()
ThresholdAtts.outputMeshType = 0
ThresholdAtts.listedVarNames = ("default")
ThresholdAtts.zonePortions = (1)
ThresholdAtts.lowerBounds = (-1e+37)
ThresholdAtts.upperBounds = (1e+37)
ThresholdAtts.defaultVarName = "avgs"
ThresholdAtts.defaultVarIsScalar = 1
SetOperatorOptions(ThresholdAtts, 1)
SetActivePlots(0)
DrawPlots()
# Begin spontaneous state
View3DAtts = View3DAttributes()
View3DAtts.viewNormal = (0.488281, 0.382966, -0.784167)
View3DAtts.focus = (-634.56, 91.3781, -13.7891)
View3DAtts.viewUp = (-0.102795, 0.917551, 0.3841)
View3DAtts.viewAngle = 30
View3DAtts.parallelScale = 1.45614e+06
View3DAtts.nearPlane = -2.91228e+06
View3DAtts.farPlane = 2.91228e+06
View3DAtts.imagePan = (0, 0)
View3DAtts.imageZoom = 1
View3DAtts.perspective = 1
View3DAtts.eyeAngle = 2
View3DAtts.centerOfRotationSet = 0
View3DAtts.centerOfRotation = (-634.56, 91.3781, -13.7891)
View3DAtts.axis3DScaleFlag = 0
View3DAtts.axis3DScales = (1, 1, 1)
View3DAtts.shear = (0, 0, 1)
SetView3D(View3DAtts)
# End spontaneous state

View3DAtts = View3DAttributes()
View3DAtts.viewNormal = (0.488281, 0.382966, -0.784167)
View3DAtts.focus = (-634.56, 91.3781, -13.7891)
View3DAtts.viewUp = (-0.102795, 0.917551, 0.3841)
View3DAtts.viewAngle = 30
View3DAtts.parallelScale = 1.45614e+06
View3DAtts.nearPlane = -2.91228e+06
View3DAtts.farPlane = 2.91228e+06
View3DAtts.imagePan = (0, 0)
View3DAtts.imageZoom = 1
View3DAtts.perspective = 1
View3DAtts.eyeAngle = 2
View3DAtts.centerOfRotationSet = 0
View3DAtts.centerOfRotation = (-634.56, 91.3781, -13.7891)
View3DAtts.axis3DScaleFlag = 0
View3DAtts.axis3DScales = (1, 1, 1)
View3DAtts.shear = (0, 0, 1)
SetView3D(View3DAtts)
ViewCurveAtts = ViewCurveAttributes()
ViewCurveAtts.domainCoords = (0, 1)
ViewCurveAtts.rangeCoords = (0, 1)
ViewCurveAtts.viewportCoords = (0.2, 0.95, 0.15, 0.95)
ViewCurveAtts.domainScale = ViewCurveAtts.LINEAR  # LINEAR, LOG
ViewCurveAtts.rangeScale = ViewCurveAtts.LINEAR  # LINEAR, LOG
SetViewCurve(ViewCurveAtts)
View2DAtts = View2DAttributes()
View2DAtts.windowCoords = (0, 1, 0, 1)
View2DAtts.viewportCoords = (0.2, 0.95, 0.15, 0.95)
View2DAtts.fullFrameActivationMode = View2DAtts.Auto  # On, Off, Auto
View2DAtts.fullFrameAutoThreshold = 100
View2DAtts.xScale = View2DAtts.LINEAR  # LINEAR, LOG
View2DAtts.yScale = View2DAtts.LINEAR  # LINEAR, LOG
View2DAtts.windowValid = 0
SetView2D(View2DAtts)
# Begin spontaneous state
View3DAtts = View3DAttributes()
View3DAtts.viewNormal = (0.488281, 0.382966, -0.784167)
View3DAtts.focus = (-634.56, 91.3781, -13.7891)
View3DAtts.viewUp = (-0.102795, 0.917551, 0.3841)
View3DAtts.viewAngle = 30
View3DAtts.parallelScale = 1.45614e+06
View3DAtts.nearPlane = -2.91228e+06
View3DAtts.farPlane = 2.91228e+06
View3DAtts.imagePan = (0, 0)
View3DAtts.imageZoom = 1
View3DAtts.perspective = 1
View3DAtts.eyeAngle = 2
View3DAtts.centerOfRotationSet = 0
View3DAtts.centerOfRotation = (-634.56, 91.3781, -13.7891)
View3DAtts.axis3DScaleFlag = 0
View3DAtts.axis3DScales = (1, 1, 1)
View3DAtts.shear = (0, 0, 1)
SetView3D(View3DAtts)
# End spontaneous state

View3DAtts = View3DAttributes()
View3DAtts.viewNormal = (0.488281, 0.382966, -0.784167)
View3DAtts.focus = (-634.56, 91.3781, -13.7891)
View3DAtts.viewUp = (-0.102795, 0.917551, 0.3841)
View3DAtts.viewAngle = 30
View3DAtts.parallelScale = 1.45614e+06
View3DAtts.nearPlane = -2.91228e+06
View3DAtts.farPlane = 2.91228e+06
View3DAtts.imagePan = (0, 0)
View3DAtts.imageZoom = 1
View3DAtts.perspective = 1
View3DAtts.eyeAngle = 2
View3DAtts.centerOfRotationSet = 0
View3DAtts.centerOfRotation = (-634.56, 91.3781, -13.7891)
View3DAtts.axis3DScaleFlag = 0
View3DAtts.axis3DScales = (1, 1, 1)
View3DAtts.shear = (0, 0, 1)
SetView3D(View3DAtts)
ViewAxisArrayAtts = ViewAxisArrayAttributes()
ViewAxisArrayAtts.domainCoords = (0, 1)
ViewAxisArrayAtts.rangeCoords = (0, 1)
ViewAxisArrayAtts.viewportCoords = (0.15, 0.9, 0.1, 0.85)
SetViewAxisArray(ViewAxisArrayAtts)
SetTimeSliderState(0)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(1)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(2)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(3)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(4)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(5)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(6)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(7)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(8)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(9)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(10)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(11)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(12)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(13)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(14)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(15)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(16)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(17)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(18)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(19)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(20)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(21)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(22)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(23)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(24)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(25)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(26)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(27)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(28)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(29)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(30)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(31)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(32)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(33)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(34)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(35)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(36)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(37)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(38)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(39)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(40)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(41)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(42)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(43)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(44)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
SetTimeSliderState(45)
SaveWindowAtts = SaveWindowAttributes()
SaveWindowAtts.outputToCurrentDirectory = 0
SaveWindowAtts.outputDirectory = "/home/hannukse/testStuff/"
SaveWindowAtts.fileName = "test_183300_"
SaveWindowAtts.family = 1
SaveWindowAtts.format = SaveWindowAtts.PNG  # BMP, CURVE, JPEG, OBJ, PNG, POSTSCRIPT, POVRAY, PPM, RGB, STL, TIFF, ULTRA, VTK, PLY
SaveWindowAtts.width = 3000
SaveWindowAtts.height = 3000
SaveWindowAtts.screenCapture = 0
SaveWindowAtts.saveTiled = 0
SaveWindowAtts.quality = 100
SaveWindowAtts.progressive = 0
SaveWindowAtts.binary = 0
SaveWindowAtts.stereo = 0
SaveWindowAtts.compression = SaveWindowAtts.PackBits  # None, PackBits, Jpeg, Deflate
SaveWindowAtts.forceMerge = 0
SaveWindowAtts.resConstraint = SaveWindowAtts.ScreenProportions  # NoConstraint, EqualWidthHeight, ScreenProportions
SaveWindowAtts.advancedMultiWindowSave = 0
SetSaveWindowAttributes(SaveWindowAtts)
SaveWindow()
DeleteActivePlots()
OpenDatabase("localhost:/home/hannukse/meteo/lustre/tmp/hannuksela/pythonTests/velgrid.rotated.183300.*.silo database")
